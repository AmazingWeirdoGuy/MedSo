Awesome—here’s a **detailed, production-minded Ghostwriter brief** you can paste into Replit. It tells it exactly what to do to (1) convert the project to **frontend-only**, (2) add a **GitHub-OAuth-protected admin page** that edits JSON content, (3) **clean up** and **harden** the codebase, and (4) make everything **portable for Vercel**.

---

# Ghostwriter Instructions — Convert to Frontend-Only, Add GitHub Admin, Clean & Make Portable for Vercel

## 0) Objectives (do all of these)

1. **Remove the backend** (no Express, no Postgres/Drizzle, no Replit OIDC, no SendGrid).
2. **Store content as JSON** in the repo, import it in the React app.
3. Add a **/admin** page that requires **GitHub OAuth** and can **edit/save JSON** through **Vercel Functions** (serverless).
4. **Clean & optimize** the codebase (delete dead code, reduce bundle size, standardize config).
5. Make the project **portable** for **Vercel** with minimal configuration.

---

## 1) Repository cleanup & standardization

* Delete Replit-specific and backend artifacts:

  * Remove: `server/` (Express code), any Replit auth/OIDC modules, SendGrid code, Postgres/Drizzle setup, `.replit`, `replit.nix`, any `REPLIT_*` usage.
  * Remove dead utils/components not referenced by the client.
  * Remove large unused assets; keep images ≤ ~500KB each (prefer `.webp`).
* Trim `package.json`:

  * Scripts should be:

    ```json
    {
      "scripts": {
        "dev": "vite",
        "build": "vite build"
      },
      "engines": { "node": ">=20" }
    }
    ```
  * Remove server-only dependencies (e.g., `express`, `pg`, `drizzle-orm`, `passport`, `@sendgrid/mail`, etc.).
* Add code quality tooling:

  * ESLint + Prettier. Create `.eslintrc.cjs`, `.prettierrc`, and add lint scripts:

    ```json
    {
      "scripts": {
        "lint": "eslint . --ext .ts,.tsx",
        "format": "prettier --write ."
      }
    }
    ```
  * (Optional) Husky + lint-staged to enforce formatting on commit.

---

## 2) Vite & paths (portable config)

* **Vite config** (`vite.config.ts`):

  * Keep existing aliases (`@`, `@shared`, optional `@assets`).
  * Ensure output is `dist/public` and dev allows external preview hosts.

  ```ts
  import { defineConfig } from "vite";
  import react from "@vitejs/plugin-react";
  import path from "path";

  export default defineConfig({
    plugins: [react()],
    resolve: {
      alias: {
        "@": path.resolve(import.meta.dirname, "client", "src"),
        "@shared": path.resolve(import.meta.dirname, "shared"),
      },
    },
    root: path.resolve(import.meta.dirname, "client"),
    build: {
      outDir: path.resolve(import.meta.dirname, "dist/public"),
      emptyOutDir: true,
    },
    server: {
      allowedHosts: ["*"], // dev convenience (Replit preview hosts)
      fs: { strict: true, deny: ["**/.*"] },
    },
  });
  ```
* **tsconfig.json**: keep `paths` aligned with Vite aliases; keep strict mode.

---

## 3) Data model → JSON files (no DB)

* Create content files:

  ```
  client/src/data/members.json
  client/src/data/programs.json
  client/src/data/news.json
  client/src/data/heroImages.json
  ```
* **Migrate existing default data** from the previous storage code into these JSONs.
* Replace any `fetch('/api/...')` calls that read data with **ES module imports**:

  ```ts
  import members from "@/data/members.json";
  ```
* Keep structures stable, e.g.:

  **members.json**

  ```json
  [
    {
      "id": "member-1",
      "name": "Sarah Johnson",
      "role": "President",
      "memberClassId": "officer",
      "bio": "Passionate about global health equity and medical education.",
      "image": "/content/media/sarah.webp",
      "linkedIn": null,
      "year": "Grade 12",
      "isActive": true,
      "displayOrder": 1
    }
  ]
  ```

---

## 4) Admin page (frontend UI at /admin)

* Add `client/src/pages/Admin.tsx` with:

  * Auth state: calls `GET /api/auth/status` on mount; if 401 → show “Sign in with GitHub” button.
  * Tabs for `members`, `programs`, `news`, `heroImages`.
  * Editor: simple `<textarea>` containing pretty-printed JSON (later can upgrade to form UI).
  * **Save** button → `POST /api/content/update` with:

    ```json
    {
      "path": "client/src/data/<file>.json",
      "content": "<the updated JSON string>",
      "message": "Update <file>"
    }
    ```
  * Sign-in: redirect to `/api/auth/login`.
  * Sign-out: `GET /api/auth/logout`, then reload.
* Ensure client router has a route for `/admin`.

---

## 5) Vercel Functions (API routes)

Create an `api/` folder at **repo root** with these files:

### 5.1 Auth — login

`api/auth/login.ts`

* Read `GITHUB_CLIENT_ID`, `OAUTH_REDIRECT_URL`.
* Generate `state`, set `oauth_state` httpOnly cookie (10 min).
* Redirect to GitHub OAuth authorize URL with scopes `repo user:email`.

### 5.2 Auth — callback

`api/auth/callback.ts`

* Validate `state` equals cookie.
* Exchange `code` → access token using `GITHUB_CLIENT_ID`, `GITHUB_CLIENT_SECRET`, `OAUTH_REDIRECT_URL`.
* (Optional hardening) If `ADMIN_GITHUB_USERNAME` is set, call `GET https://api.github.com/user` and **reject** if `login` does not match (403).
* Create a signed session cookie:

  * Value: base64 of `{ token }`.
  * Signature: HMAC-SHA256 with `COOKIE_SECRET`.
  * Cookie flags: `HttpOnly; Secure; SameSite=Lax; Max-Age=2592000`.
* Clear `oauth_state` cookie.
* Redirect to `/admin`.

### 5.3 Auth — status

`api/auth/status.ts`

* Verify session cookie’s signature.
* If valid → `200 { ok: true }`, else `401`.

### 5.4 Auth — logout

`api/auth/logout.ts`

* Clear session cookie.
* Return `200`.

### 5.5 Content — update

`api/content/update.ts`

* Method: POST only.
* Verify session cookie; extract token or (optionally) fall back to repo PAT.
* Body: `{ path, content, message }` (validate shape; ensure `path` starts with `client/src/data/`).
* Use **GitHub Contents API**:

  * GET file to obtain `sha` (if exists): `/repos/:owner/:repo/contents/:path?ref=:branch`
  * PUT new content (base64) with commit message and `sha`.
* Env vars needed:

  * `GITHUB_REPO_OWNER`, `GITHUB_REPO_NAME`, `GITHUB_REPO_BRANCH` (default `main`).
* Return `200 { ok: true }` on success; include GitHub response error text if it fails.

> Keep these functions dependency-light (use native `fetch`, `crypto`).

---

## 6) Environment variables (Vercel → Project → Settings → Env Vars)

Set these in **Production** (and Preview if needed):

```
GITHUB_CLIENT_ID=xxxx
GITHUB_CLIENT_SECRET=xxxx
GITHUB_REPO_OWNER=AmazingWeirdoGuy
GITHUB_REPO_NAME=Club-Website
GITHUB_REPO_BRANCH=main
OAUTH_REDIRECT_URL=https://<your-vercel-domain>.vercel.app/api/auth/callback
COOKIE_SECRET=<long-random-string>
ADMIN_GITHUB_USERNAME=<optional exact username for lock-down>
```

*(If you prefer, support a `GITHUB_PAT` fallback for commits and use that instead of the user token.)*

---

## 7) SPA routing & static admin

* Create `vercel.json` at repo root:

  ```json
  {
    "rewrites": [
      { "source": "/api/(.*)", "destination": "/api/$1" },
      { "source": "/(.*)", "destination": "/" }
    ]
  }
  ```
* If you place a **static** admin (Decap) under `client/public/admin/`, add routes:

  ```json
  {
    "routes": [
      { "src": "/admin", "dest": "/admin/index.html" },
      { "src": "/admin/(.*)", "dest": "/admin/index.html" }
    ]
  }
  ```
* Otherwise, if `/admin` is part of the SPA, the standard SPA rewrite is sufficient.

---

## 8) Optional: Decap CMS instead of custom Admin

* Put files here:

  ```
  client/public/admin/index.html   // loads decap script
  client/public/admin/config.yml   // YAML, points to repo & collections
  ```
* In `config.yml` use:

  ```yml
  backend:
    name: github
    repo: AmazingWeirdoGuy/Club-Website
    branch: main
    base_url: /
    auth_endpoint: api/auth
  ```
* Collections should map to `client/public/content/...` or to the JSONs depending on your decision. Ensure the YAML is valid (spaces only, no HTML).
* Keep the same `/api/auth/*` endpoints; Decap will use them.

---

## 9) Performance & bundle hygiene

* Verify chunk sizes; introduce **dynamic imports** where reasonable (e.g., heavy pages).
* Convert heavy JPG/PNG to **WebP**; ensure hero images under ~500KB.
* Remove unused imports, components, and routes.
* Tree-shake third-party libraries (avoid importing all of `lodash`, etc.).
* Consider adding `vite-plugin-compression` (optional) if needed.

---

## 10) Security hardening

* Admin restriction:

  * Enforce `ADMIN_GITHUB_USERNAME` in callback.
  * Validate `state` and use short-lived cookie.
* Cookie:

  * `HttpOnly; Secure; SameSite=Lax; Max-Age=30d`.
  * HMAC sign payload with `COOKIE_SECRET`.
* Input validation:

  * In `update.ts`, only allow writes under `client/src/data/`.
  * Reject paths with `..` or absolute paths.
  * Validate `content` is valid JSON (try/catch parse; reject if invalid).

---

## 11) Documentation (README.md)

Add a thorough README:

* **Overview** of architecture (frontend-only + Vercel Functions for auth/commits).
* Local dev:

  * `npm i`
  * `npm run dev` (explain JSON imports)
* Deploy on Vercel:

  * Framework preset: **Vite**
  * Build command: `npm run build`
  * Output dir: `dist/public`
  * Env vars list
* Admin usage:

  * `/admin` login, edit, save → commits to repo → redeploy.
* How to change data schema (field additions to JSON and UI).

---

## 12) Final acceptance criteria

* ✅ `npm run build` passes; deploy on Vercel with output `dist/public`.
* ✅ Site loads all content from `client/src/data/*.json` via imports (no runtime API fetches).
* ✅ `/admin`:

  * Unauthed → shows GitHub sign-in.
  * Authed → shows editor; **Save** commits JSON to GitHub on the configured branch.
* ✅ Commit triggers a Vercel redeploy; updated content visible post-deploy.
* ✅ No references to Replit OIDC, Postgres/Drizzle, Express, or SendGrid remain.
* ✅ ESLint/Prettier pass; repo has no obvious dead code or large unused assets.

---

## 13) Nice-to-have (if time permits)

* Switch **Save** to open a **pull request** instead of pushing to `main`.
* Add **Zod** validation for JSON before commit.
* Replace `<textarea>` with a form/editor UI for better UX (sortable members by `displayOrder`, image pickers, etc.).
* Add minimal unit tests for the API functions (mock fetch).

---

**Do all steps above.** Keep the footprint small, ensure the app is fully **backend-free** (except Vercel Functions), and make the codebase clean and portable for Vercel.
